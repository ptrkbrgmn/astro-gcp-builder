---
import { createReadStream } from 'fs';
import path from 'path';
import BaseLayout from '../../layouts/BaseLayout.astro';
import type { GetStaticPathsResult } from 'astro';

import chain from 'stream-chain'; 
import parser from 'stream-json';
import pick from 'stream-json/filters/Pick';
import streamArray from 'stream-json/streamers/StreamArray';

interface Post {
  slug: string;
  title: string;
  author: string;
  content: string;
}

export async function getStaticPaths(): Promise<GetStaticPathsResult> {
  const pages: { params: { slug: string }; props: { post: Post } }[] = [];
  
  const jsonPath = process.env.JSON_FILE_PATH || path.resolve(process.cwd(), 'src/data/posts.json');

  if (!jsonPath) {
    throw new Error("Could not determine JSON file path!");
  }
  console.log(`Streaming data from: ${jsonPath}`);

  // âœ… 1. Create a pipeline using the 'chain' function.
  // This is the key to getting a correctly typed AsyncIterable.
  const pipeline = new chain([
    parser(),
    new pick({ filter: '' }), // Pick all items from the root level
    new streamArray()
  ] as any);

  // 2. Pipe the file stream INTO the pipeline's input.
  createReadStream(jsonPath).pipe(pipeline);

  // 3. The pipeline itself is the iterable. This works without errors.
  for await (const { value } of pipeline) {
    const post = value as Post;
    pages.push({
      params: { slug: post.slug },
      props: { post },
    });
  }
  
  console.log(`Finished streaming. Generated ${pages.length} pages.`);
  return pages;
}

interface Props {
  post: Post;
}

const { post } = Astro.props as Props;
---
<BaseLayout title={post.title}>
  <h1>{post.title}</h1>
  <p><em>By {post.author}</em></p>
  <hr>
  <p>{post.content}</p>
</BaseLayout>